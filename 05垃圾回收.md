## 垃圾回收

##### 引用计数法：

​		为每个对象添加一个引用计数器，来统计指向该对象的引用个数，一旦某个对象引用器为0时，则数目这个对象已经死了，需要回收

​		问题：无法解决 **循环引用** 问题

​					如果a和b互相引用，当a和b实际已经死了的情况下，他们的引用计数都不为0，会导致无法回收，最终导致内存泄露



##### 可达性分析：

​		GC Roots（起始存活对象集合 live set）-> 从这个集合开始探索所有能够被该集合引用的对象，并将其加入该集合中（标记Mark）；最终未被探索到的对象便是死亡的，可回收

​		多线程环境下存在误报（将引用设置为null）和漏报（将引用设置为未被访问过的对象-新对象）



##### 安全点：

​		解决多线程环境下漏报问题

​		传统的解决方法：Stop-the-world 即停止其他非垃圾回收线程的工作，直到完成垃圾回收，造成了垃圾回收的暂停时间（GC pause）

​		安全点（safepoint）机制，Java虚拟机收到Stop-the-world请求，便会等待所有的线程到达安全点，才允许请求Stop-the-world的线程进行独占的工作；

​		安全点的定义：虚拟机定义了一下情况为安全点，并对应一写安全点的检测机制（当有安全点请求时，执行一条字节码便进行一次安全点的检测）



##### 回收：

- 清除（sweep）：将死亡对象的内存标记为空闲内存，并记录到空闲列表（free list）中
  - 缺点：
    - 造成内存碎片：JVM的堆中对象必须是连续分布的，所有可能出现总空闲内存很多，但是无法分配的极端情况
    - 分配效率低：需要逐个访问空闲列表中的项，来查找能够分配新建对象的空闲内存（如果是一块连续的内存，直接进行指针加法（pointer bumping）来做分配）
- 压缩（compact）：将存活的对象聚集到内存区域的起始位置
  - 优点：减少内存碎片化问题
  - 缺点：压缩算法的性能开销
- 复制（copy）：将内存分成两等分，分别用from和to两个指针来维护两块内存，只有from区域的内存可以用来分配，当发生垃圾回收时，便将存活的对象复制到to指针指向的内存中，并交换from和to的指针内容
  - 缺点：内存使用率低

现代垃圾回收器会综合上述几种回收方式，取优点规避缺点。



