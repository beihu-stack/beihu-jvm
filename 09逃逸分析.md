## 逃逸分析

一种确定指针动态范围的静态分析，可以分析在程序的哪些地方可以访问到指针。（不逃逸，即可优化）

通常，即时编译里面的逃逸分析是放在方法内联之后的，以便消除“未知代码”(未被内联的方法)



##### 基于逃逸分析的优化：

即时编译器可根据逃逸分析的结果进行如：锁消除、**栈上分配**以及标量替换的优化。

- 锁消除：即时编译器可消除对不逃逸的锁对象的加锁、解锁操作。（**锁对象不逃逸出当前编译的方法**）

- 栈上分配：JVM中的对象都在堆上分配，而堆上的内容对任何线程都是可见的，同时JVM需要对所分配的内存进行管理，并在对象不再被使用时回收。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM可以完全将他分配到栈上，并在new语句所在的方法退出时，通过弹出当前方法的栈帧来自动回收所分配的内存空间。

- 标量替换：由于栈上分配实现起来需要更改大量假设了“对象只能堆分配”的代码，因此HotSpot虚拟机并没有采用栈上分配，而是使用了一种标量替换技术。
  - 标量：能够存储一个值的变量（例如：局部变量）
  - 将原本对对象的字段的访问，替换为一个个局部变量的访问



##### 部分逃逸分析：（Graal即时编译器支持，但耗时更久）

解决了所新建的实例仅在部分程序路径中逃逸的情况。

