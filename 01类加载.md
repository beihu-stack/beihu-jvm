## 类加载



### 前言知识

> * class文件到内存中的类需要：加载、链接、初始化
>   * 链接需要进行验证
>   * 内存中的类初始化后才能被使用

> * Java语言类型：
>   * 基本类型
>   * 引用类型：
>     * 类、接口、数组类（虚拟机直接生成）、泛型（擦除）
> * 字节流（数组类无字节流）
>   * class文件
>   * 网络字节流



### 加载

类加载器：加载字节流，创建类

> * 启动类加载器（Boot Class Loader）
>   * 由C++实现，无对应Java对象，用null代替
>   * Java9之前，加载最基础、最重要的类（JRE的lib下的，及-Xbootclasspath指定的类）
> * java.lang.ClassLoader
>   * 其他类加载器的父类
>     * 扩展类加载器（Extension Class Loader）
>       * 父加载器 启动类加载器
>       * 加载JRE lib下的/ext目录下的jar包，及系统环境变量java.ext.dirs指定类
>     * 应用类加载器（Application Class Loader）
>       * 父加载器 扩展类加载器
>       * 加载应用程序路径下的类（即虚拟机 -cp/-classpath、系统环境变量java.class.path或者环境变量CLASSPATH所指定的路径）
> * 双亲委派模型
>   * 类加载器接收到加载请求会先将请求交给父类加载器加载，当父类加载器没有找到所请求的类时，该类加载器才尝试去加载
> * Java9引入了模块系统
>   * 扩展类加载器 修改为 平台类加载（Platform Class Loader）
> * 类的唯一性
>   * Java虚拟机中类的唯一性由：类加载器实例、类的全限定名确定（命名空间，类隔离）



### 链接

将创建好的类合并到Java虚拟机中，使其能够执行

分三个阶段

##### 1. 验证

​		确保被加载的类满足Java虚拟机的约束条件

##### 2. 准备

​		为被加载类的静态字段分配内存、虚方法动态绑定方法表（无法确定类或方法，编译器会生成一个符号引用）

##### 3. 解析（非必须）

​		将符号引用解析为实际引用（如果符号引用指向一个未被加载的类，或为被加载类的方法或字段，将触发该类的加载）



### 初始化

为标记为常量值的字段赋值或执行对应方法（加锁执行方法）

只有当初始化完成后，类才变成可执行状态

加锁，线程安全



类初始化的触发：（JVM规范）

- 当虚拟机启动时，初始化用户指定的主类
- 当遇到用new指令是，初始化new指令的目标类
- 当遇到调用静态方法的指令时，初始化该静态方法所在的类
- 当遇到访问静态字段的指令时，初始化该静态字段所在的类
- 子类初始化会触发父类的初始化
- 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化会触发该接口的初始化

- 使用反射API对某个类进行反射调用时，初始化这个类
- 当初次使用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类

​		